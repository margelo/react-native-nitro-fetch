///
/// UploadDataSink.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `UploadDataSink`, backed by a C++ struct.
 */
public typealias UploadDataSink = margelo.nitro.nitrofetch.UploadDataSink

public extension UploadDataSink {
  private typealias bridge = margelo.nitro.nitrofetch.bridge.swift

  /**
   * Create a new instance of `UploadDataSink`.
   */
  init(onReadSucceeded: @escaping (_ finalChunk: Bool) -> Void, onReadError: @escaping (_ error: String) -> Void, onRewindSucceeded: @escaping () -> Void, onRewindError: @escaping (_ error: String) -> Void) {
    self.init({ () -> bridge.Func_void_bool in
      let __closureWrapper = Func_void_bool(onReadSucceeded)
      return bridge.create_Func_void_bool(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_std__string in
      let __closureWrapper = Func_void_std__string(onReadError)
      return bridge.create_Func_void_std__string(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void in
      let __closureWrapper = Func_void(onRewindSucceeded)
      return bridge.create_Func_void(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_std__string in
      let __closureWrapper = Func_void_std__string(onRewindError)
      return bridge.create_Func_void_std__string(__closureWrapper.toUnsafe())
    }())
  }

  var onReadSucceeded: (_ finalChunk: Bool) -> Void {
    @inline(__always)
    get {
      return { () -> (Bool) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_bool(self.__onReadSucceeded)
        return { (__finalChunk: Bool) -> Void in
          __wrappedFunction.call(__finalChunk)
        }
      }()
    }
    @inline(__always)
    set {
      self.__onReadSucceeded = { () -> bridge.Func_void_bool in
        let __closureWrapper = Func_void_bool(newValue)
        return bridge.create_Func_void_bool(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onReadError: (_ error: String) -> Void {
    @inline(__always)
    get {
      return { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(self.__onReadError)
        return { (__error: String) -> Void in
          __wrappedFunction.call(std.string(__error))
        }
      }()
    }
    @inline(__always)
    set {
      self.__onReadError = { () -> bridge.Func_void_std__string in
        let __closureWrapper = Func_void_std__string(newValue)
        return bridge.create_Func_void_std__string(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onRewindSucceeded: () -> Void {
    @inline(__always)
    get {
      return { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(self.__onRewindSucceeded)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }()
    }
    @inline(__always)
    set {
      self.__onRewindSucceeded = { () -> bridge.Func_void in
        let __closureWrapper = Func_void(newValue)
        return bridge.create_Func_void(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onRewindError: (_ error: String) -> Void {
    @inline(__always)
    get {
      return { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(self.__onRewindError)
        return { (__error: String) -> Void in
          __wrappedFunction.call(std.string(__error))
        }
      }()
    }
    @inline(__always)
    set {
      self.__onRewindError = { () -> bridge.Func_void_std__string in
        let __closureWrapper = Func_void_std__string(newValue)
        return bridge.create_Func_void_std__string(__closureWrapper.toUnsafe())
      }()
    }
  }
}
