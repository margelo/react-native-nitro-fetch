///
/// NitroResponse.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `NitroResponse`, backed by a C++ struct.
 */
public typealias NitroResponse = margelo.nitro.nitrofetch.NitroResponse

public extension NitroResponse {
  private typealias bridge = margelo.nitro.nitrofetch.bridge.swift

  /**
   * Create a new instance of `NitroResponse`.
   */
  init(url: String, status: Double, statusText: String, ok: Bool, redirected: Bool, headers: [NitroHeader], stream: @escaping (_ callbacks: StreamCallbacks) -> Void, cancel: @escaping () -> Void) {
    self.init(std.string(url), status, std.string(statusText), ok, redirected, headers.withUnsafeBufferPointer { __pointer -> bridge.std__vector_NitroHeader_ in
      return bridge.copy_std__vector_NitroHeader_(__pointer.baseAddress!, headers.count)
    }, { () -> bridge.Func_void_StreamCallbacks in
      let __closureWrapper = Func_void_StreamCallbacks(stream)
      return bridge.create_Func_void_StreamCallbacks(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void in
      let __closureWrapper = Func_void(cancel)
      return bridge.create_Func_void(__closureWrapper.toUnsafe())
    }())
  }

  var url: String {
    @inline(__always)
    get {
      return String(self.__url)
    }
    @inline(__always)
    set {
      self.__url = std.string(newValue)
    }
  }
  
  var status: Double {
    @inline(__always)
    get {
      return self.__status
    }
    @inline(__always)
    set {
      self.__status = newValue
    }
  }
  
  var statusText: String {
    @inline(__always)
    get {
      return String(self.__statusText)
    }
    @inline(__always)
    set {
      self.__statusText = std.string(newValue)
    }
  }
  
  var ok: Bool {
    @inline(__always)
    get {
      return self.__ok
    }
    @inline(__always)
    set {
      self.__ok = newValue
    }
  }
  
  var redirected: Bool {
    @inline(__always)
    get {
      return self.__redirected
    }
    @inline(__always)
    set {
      self.__redirected = newValue
    }
  }
  
  var headers: [NitroHeader] {
    @inline(__always)
    get {
      return { () -> [NitroHeader] in
        let __data = bridge.get_data_std__vector_NitroHeader_(self.__headers)
        let __size = self.__headers.size()
        return Array(UnsafeBufferPointer(start: __data, count: __size))
      }()
    }
    @inline(__always)
    set {
      self.__headers = newValue.withUnsafeBufferPointer { __pointer -> bridge.std__vector_NitroHeader_ in
        return bridge.copy_std__vector_NitroHeader_(__pointer.baseAddress!, newValue.count)
      }
    }
  }
  
  var stream: (_ callbacks: StreamCallbacks) -> Void {
    @inline(__always)
    get {
      return { () -> (StreamCallbacks) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_StreamCallbacks(self.__stream)
        return { (__callbacks: StreamCallbacks) -> Void in
          __wrappedFunction.call(__callbacks)
        }
      }()
    }
    @inline(__always)
    set {
      self.__stream = { () -> bridge.Func_void_StreamCallbacks in
        let __closureWrapper = Func_void_StreamCallbacks(newValue)
        return bridge.create_Func_void_StreamCallbacks(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var cancel: () -> Void {
    @inline(__always)
    get {
      return { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(self.__cancel)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }()
    }
    @inline(__always)
    set {
      self.__cancel = { () -> bridge.Func_void in
        let __closureWrapper = Func_void(newValue)
        return bridge.create_Func_void(__closureWrapper.toUnsafe())
      }()
    }
  }
}
