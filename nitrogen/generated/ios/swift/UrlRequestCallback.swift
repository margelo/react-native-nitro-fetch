///
/// UrlRequestCallback.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `UrlRequestCallback`, backed by a C++ struct.
 */
public typealias UrlRequestCallback = margelo.nitro.nitrofetch.UrlRequestCallback

public extension UrlRequestCallback {
  private typealias bridge = margelo.nitro.nitrofetch.bridge.swift

  /**
   * Create a new instance of `UrlRequestCallback`.
   */
  init(onRedirectReceived: @escaping (_ info: UrlResponseInfo, _ newLocationUrl: String) -> Void, onResponseStarted: @escaping (_ info: UrlResponseInfo) -> Void, onReadCompleted: @escaping (_ info: UrlResponseInfo, _ byteBuffer: ArrayBuffer) -> Void, onSucceeded: @escaping (_ info: UrlResponseInfo) -> Void, onFailed: @escaping (_ info: UrlResponseInfo?, _ error: (any HybridRequestExceptionSpec)) -> Void, onCanceled: @escaping (_ info: UrlResponseInfo?) -> Void) {
    self.init({ () -> bridge.Func_void_UrlResponseInfo_std__string in
      let __closureWrapper = Func_void_UrlResponseInfo_std__string(onRedirectReceived)
      return bridge.create_Func_void_UrlResponseInfo_std__string(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_UrlResponseInfo in
      let __closureWrapper = Func_void_UrlResponseInfo(onResponseStarted)
      return bridge.create_Func_void_UrlResponseInfo(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_UrlResponseInfo_std__shared_ptr_ArrayBuffer_ in
      let __closureWrapper = Func_void_UrlResponseInfo_std__shared_ptr_ArrayBuffer_(onReadCompleted)
      return bridge.create_Func_void_UrlResponseInfo_std__shared_ptr_ArrayBuffer_(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_UrlResponseInfo in
      let __closureWrapper = Func_void_UrlResponseInfo(onSucceeded)
      return bridge.create_Func_void_UrlResponseInfo(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_std__optional_UrlResponseInfo__std__shared_ptr_HybridRequestExceptionSpec_ in
      let __closureWrapper = Func_void_std__optional_UrlResponseInfo__std__shared_ptr_HybridRequestExceptionSpec_(onFailed)
      return bridge.create_Func_void_std__optional_UrlResponseInfo__std__shared_ptr_HybridRequestExceptionSpec_(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_std__optional_UrlResponseInfo_ in
      let __closureWrapper = Func_void_std__optional_UrlResponseInfo_(onCanceled)
      return bridge.create_Func_void_std__optional_UrlResponseInfo_(__closureWrapper.toUnsafe())
    }())
  }

  var onRedirectReceived: (_ info: UrlResponseInfo, _ newLocationUrl: String) -> Void {
    @inline(__always)
    get {
      return { () -> (UrlResponseInfo, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_UrlResponseInfo_std__string(self.__onRedirectReceived)
        return { (__info: UrlResponseInfo, __newLocationUrl: String) -> Void in
          __wrappedFunction.call(__info, std.string(__newLocationUrl))
        }
      }()
    }
    @inline(__always)
    set {
      self.__onRedirectReceived = { () -> bridge.Func_void_UrlResponseInfo_std__string in
        let __closureWrapper = Func_void_UrlResponseInfo_std__string(newValue)
        return bridge.create_Func_void_UrlResponseInfo_std__string(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onResponseStarted: (_ info: UrlResponseInfo) -> Void {
    @inline(__always)
    get {
      return { () -> (UrlResponseInfo) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_UrlResponseInfo(self.__onResponseStarted)
        return { (__info: UrlResponseInfo) -> Void in
          __wrappedFunction.call(__info)
        }
      }()
    }
    @inline(__always)
    set {
      self.__onResponseStarted = { () -> bridge.Func_void_UrlResponseInfo in
        let __closureWrapper = Func_void_UrlResponseInfo(newValue)
        return bridge.create_Func_void_UrlResponseInfo(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onReadCompleted: (_ info: UrlResponseInfo, _ byteBuffer: ArrayBuffer) -> Void {
    @inline(__always)
    get {
      return { () -> (UrlResponseInfo, ArrayBuffer) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_UrlResponseInfo_std__shared_ptr_ArrayBuffer_(self.__onReadCompleted)
        return { (__info: UrlResponseInfo, __byteBuffer: ArrayBuffer) -> Void in
          __wrappedFunction.call(__info, __byteBuffer)
        }
      }()
    }
    @inline(__always)
    set {
      self.__onReadCompleted = { () -> bridge.Func_void_UrlResponseInfo_std__shared_ptr_ArrayBuffer_ in
        let __closureWrapper = Func_void_UrlResponseInfo_std__shared_ptr_ArrayBuffer_(newValue)
        return bridge.create_Func_void_UrlResponseInfo_std__shared_ptr_ArrayBuffer_(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onSucceeded: (_ info: UrlResponseInfo) -> Void {
    @inline(__always)
    get {
      return { () -> (UrlResponseInfo) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_UrlResponseInfo(self.__onSucceeded)
        return { (__info: UrlResponseInfo) -> Void in
          __wrappedFunction.call(__info)
        }
      }()
    }
    @inline(__always)
    set {
      self.__onSucceeded = { () -> bridge.Func_void_UrlResponseInfo in
        let __closureWrapper = Func_void_UrlResponseInfo(newValue)
        return bridge.create_Func_void_UrlResponseInfo(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onFailed: (_ info: UrlResponseInfo?, _ error: (any HybridRequestExceptionSpec)) -> Void {
    @inline(__always)
    get {
      return { () -> (UrlResponseInfo?, (any HybridRequestExceptionSpec)) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__optional_UrlResponseInfo__std__shared_ptr_HybridRequestExceptionSpec_(self.__onFailed)
        return { (__info: UrlResponseInfo?, __error: (any HybridRequestExceptionSpec)) -> Void in
          __wrappedFunction.call({ () -> bridge.std__optional_UrlResponseInfo_ in
            if let __unwrappedValue = __info {
              return bridge.create_std__optional_UrlResponseInfo_(__unwrappedValue)
            } else {
              return .init()
            }
          }(), { () -> bridge.std__shared_ptr_HybridRequestExceptionSpec_ in
            let __cxxWrapped = __error.getCxxWrapper()
            return __cxxWrapped.getCxxPart()
          }())
        }
      }()
    }
    @inline(__always)
    set {
      self.__onFailed = { () -> bridge.Func_void_std__optional_UrlResponseInfo__std__shared_ptr_HybridRequestExceptionSpec_ in
        let __closureWrapper = Func_void_std__optional_UrlResponseInfo__std__shared_ptr_HybridRequestExceptionSpec_(newValue)
        return bridge.create_Func_void_std__optional_UrlResponseInfo__std__shared_ptr_HybridRequestExceptionSpec_(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onCanceled: (_ info: UrlResponseInfo?) -> Void {
    @inline(__always)
    get {
      return { () -> (UrlResponseInfo?) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__optional_UrlResponseInfo_(self.__onCanceled)
        return { (__info: UrlResponseInfo?) -> Void in
          __wrappedFunction.call({ () -> bridge.std__optional_UrlResponseInfo_ in
            if let __unwrappedValue = __info {
              return bridge.create_std__optional_UrlResponseInfo_(__unwrappedValue)
            } else {
              return .init()
            }
          }())
        }
      }()
    }
    @inline(__always)
    set {
      self.__onCanceled = { () -> bridge.Func_void_std__optional_UrlResponseInfo_ in
        let __closureWrapper = Func_void_std__optional_UrlResponseInfo_(newValue)
        return bridge.create_Func_void_std__optional_UrlResponseInfo_(__closureWrapper.toUnsafe())
      }()
    }
  }
}
