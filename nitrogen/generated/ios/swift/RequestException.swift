///
/// RequestException.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `RequestException`, backed by a C++ struct.
 */
public typealias RequestException = margelo.nitro.nitrofetch.RequestException

public extension RequestException {
  private typealias bridge = margelo.nitro.nitrofetch.bridge.swift

  /**
   * Create a new instance of `RequestException`.
   */
  init(platform: ExceptionPlatform, message: String, code: Double, errorType: ErrorType, internalErrorCode: Double?, networkErrorCode: Double?, quicErrorCode: Double?, stackTrace: String?, errorDomain: Double?, localizedDescription: String?, underlyingError: String?, failingURL: String?, causeMessage: String?) {
    self.init(platform, std.string(message), code, errorType, { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = internalErrorCode {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = networkErrorCode {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = quicErrorCode {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = stackTrace {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = errorDomain {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = localizedDescription {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = underlyingError {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = failingURL {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = causeMessage {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }())
  }

  var platform: ExceptionPlatform {
    @inline(__always)
    get {
      return self.__platform
    }
    @inline(__always)
    set {
      self.__platform = newValue
    }
  }
  
  var message: String {
    @inline(__always)
    get {
      return String(self.__message)
    }
    @inline(__always)
    set {
      self.__message = std.string(newValue)
    }
  }
  
  var code: Double {
    @inline(__always)
    get {
      return self.__code
    }
    @inline(__always)
    set {
      self.__code = newValue
    }
  }
  
  var errorType: ErrorType {
    @inline(__always)
    get {
      return self.__errorType
    }
    @inline(__always)
    set {
      self.__errorType = newValue
    }
  }
  
  var internalErrorCode: Double? {
    @inline(__always)
    get {
      return self.__internalErrorCode.value
    }
    @inline(__always)
    set {
      self.__internalErrorCode = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var networkErrorCode: Double? {
    @inline(__always)
    get {
      return self.__networkErrorCode.value
    }
    @inline(__always)
    set {
      self.__networkErrorCode = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var quicErrorCode: Double? {
    @inline(__always)
    get {
      return self.__quicErrorCode.value
    }
    @inline(__always)
    set {
      self.__quicErrorCode = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var stackTrace: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__stackTrace) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__stackTrace)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__stackTrace = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var errorDomain: Double? {
    @inline(__always)
    get {
      return self.__errorDomain.value
    }
    @inline(__always)
    set {
      self.__errorDomain = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var localizedDescription: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__localizedDescription) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__localizedDescription)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__localizedDescription = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var underlyingError: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__underlyingError) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__underlyingError)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__underlyingError = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var failingURL: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__failingURL) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__failingURL)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__failingURL = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var causeMessage: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__causeMessage) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__causeMessage)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__causeMessage = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
}
